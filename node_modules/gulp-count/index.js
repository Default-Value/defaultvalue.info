// Generated by CoffeeScript 1.7.1
(function() {
  var DEFAULT_MSG, extend, gutil, path, through;

  gutil = require('gulp-util');

  through = require('through2');

  extend = require('xtend');

  path = require('path');

  DEFAULT_MSG = '<%= files %>';


  /*
  Count files in stream and log message when stream ends. Only counts *files*, ignores directories and
  other types of stream contents. Supports buffer and stream contents. Passes files through unchanged.
  Message is passed through `gutil.template` to allow for custom formatting. Also supports custom
  logging (but defaults to `gutil.log`).
  
  @param message [String] optional message format (see options)
  @param options [Object] options object
  @option options [String] message message format string (default: `'## files'`). template has two
    variables: `counter` - the number of files processed, and `files` - string of the format
    `X file[s]` where X is `counter` and 'files' is pluralized if necessary. the symbol `'##'`
    is expanded internally to `<%= counter %>`. an explicit `false` value disables logging a message
    when the stream ends.
  @option options [String] title string prepended to every message `"[title]: [message]"`
  @option options [Boolean|String] logFiles whether to log each file path as it is counted. if a
    string is provided then it is used as the message template. template has two variables: `file` -
    vinyl file instance, and `path` - file path resolved relative to `cwd` and colored yellow.
    (default: `false`)
  @option options [String] cwd directory for logging relative file paths (default: `''`)
  @option options [Function] logger function to call with formatted message (default: `gutil.log`)
  @option options [Boolean|String] logEmpty whether to log empty streams (no files). if a
    string is provided then it is used as the message template. (default: `false`)
  @example
    gulp.src('*.html')
      .pipe count() # logs '36 files'
      .pipe count('found ## pages') # logs 'found 36 pages'
      .pipe count('<%= counter %> HTML files')  # logs '36 HTML files'
      .pipe count
        message: '<%= files %>? That\'s ## too many!'
        logger: (msg) -> alert(msg) # alerts "36 files? That's 36 too many!"
   */

  module.exports = function(message, options) {
    var counter, increment, log, logCount;
    if (options == null) {
      options = {};
    }
    if (typeof message === 'object') {
      options = message;
      message = void 0;
    }
    options = extend({
      cwd: '',
      title: null,
      logger: gutil.log,
      message: message != null ? message : DEFAULT_MSG,
      logEmpty: false
    }, options);
    if (options.message === true) {
      options.message = DEFAULT_MSG;
    }
    counter = 0;
    log = function(msg) {
      if (options.title) {
        msg = options.title + ": " + msg;
      }
      return options.logger(msg);
    };
    increment = function(file, enc, cb) {
      var filepath;
      counter++;
      if (options.logFiles) {
        filepath = gutil.colors.yellow(path.relative(options.cwd, file.path));
        if (typeof options.logFiles === 'string') {
          log(gutil.template(options.logFiles, {
            path: filepath,
            file: file
          }));
        } else {
          log(filepath);
        }
      }
      return cb(null, file);
    };
    logCount = function(cb) {
      var counterStr, filesStr;
      counterStr = gutil.colors.magenta(counter);
      filesStr = "" + counterStr + " file" + (counter !== 1 ? 's' : '');
      if (counter === 0 && options.logEmpty) {
        message = typeof options.logEmpty === 'string' ? options.logEmpty : DEFAULT_MSG;
        log(gutil.template(message, {
          files: filesStr,
          counter: counterStr,
          file: null
        }));
      } else if (counter > 0 && typeof options.message === 'string') {
        message = options.message.replace('##', '<%= counter %>');
        log(gutil.template(message, {
          files: filesStr,
          counter: counterStr,
          file: null
        }));
      }
      return cb();
    };
    return through.obj(increment, logCount);
  };

}).call(this);
